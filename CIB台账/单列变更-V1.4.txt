# -*- coding: utf-8 -*-
import pandas as pd
import re
import time
from datetime import datetime
import numpy as np
import tkinter as tk
from tkinter import filedialog
import xlwings as xw
import openpyxl
import os
import json
from openpyxl.utils import get_column_letter
from openpyxl.styles import PatternFill, Alignment, Font,Border,Side
from tqdm import tqdm
from openpyxl.utils.cell import coordinate_from_string
from openpyxl.utils import column_index_from_string
from openpyxl import Workbook

def select_excel_file():
    """选择Excel文件的对话框"""
    return filedialog.askopenfilename(title="选择Excel文件", filetypes=[("Excel Files", "*.xlsx;*.xls")])


file_path = select_excel_file()
if not file_path:
    print("没有选择文件。")
sheet_name = 'Sheet1'

# 打开Excel文件并激活工作表
wb = xw.Book(file_path)
sht1 = wb.sheets[sheet_name]
book_name=sht1.range('A1').value
sht1.range('O6').value="计划\nPlan" #修改原表中的制造分部df1中标题防止出现重复列
 # 定义需要移除的列名列表
columns_to_drop = ['工艺\nMET', '变更通知编号\nECN','外控\nSQC', '内控\nQC','采购\nPROC', '运维\nO&M', '项目\nPM', '工程\nENG', 
                        '售后质量', '基线范围\nScope of influence','供应商整改范围\nScope of Supplier','Engineer', '质量-外控','质量-内控','售后质量', '运维', '项目', '工程']

# 获取当前日期并格式化为年月日形式
current_datetime = datetime.now().strftime('%Y%m%d %H-%M')
# 使用日期作为后缀创建新工作簿的名称
excel_file_name = f"{book_name}_TS_{current_datetime}.xlsx"



def main():
    # 假设 sht1 是一个有效的表格或工作表对象，book_name 是项目的名称
    df_TS_info, df_Car_info, train_consist, project_ID = load_or_calculate_data(sht1, book_name)


    # 调用函数,构造出车辆结构
    nested_dict = build_project_car_dict(project_ID,df_TS_info, df_Car_info, train_consist)
    

    total_sheets = len(df_TS_info)

    df1_1 = get_data_from_range(sht1, 'A6:S6', 1, 19)
    df1_2 = get_data_from_range(sht1, 'W6:Y6', 23, 25)
    df1_3 = get_data_from_range(sht1, 'T8:U8', 20, 21)
    df1 = pd.concat([df1_1, df1_2,df1_3], axis=1)
    # print(df1)
    # 移除df1中不必要的列
    df1.drop(columns=columns_to_drop, errors='ignore', inplace=True)
    #使用正则表达式将df1标题中\n之后的英文去除
    df1.columns = [re.sub(r'\n[a-zA-Z ]*', '', name) for name in df1.columns]

    #遍历 df_Car_info,修改列名，增加车辆编号
    for index, row in df_Car_info.iterrows():
        start_address = f"{get_column_letter(row['Start_Column'])}9"
        end_address = f"{get_column_letter(row['End_Column'])}9"
        car_NO= row['Merge_Context']
        for i in sht1.range(f"{start_address}: {end_address}"):
            # 判断range(i).value的值是否已经包含car_NO
            if car_NO not in i.value:
                sht1.range(i).value = f"{car_NO}\n{sht1.range(i).value}"

    wb1 = Workbook()
    ws = wb1.active
    ws.title = "Sheet1"  # 设置工作表的标题
    with tqdm(total=total_sheets, desc="Writing Sheets:", unit="sheets") as sheets_pbar:

        with pd.ExcelWriter(excel_file_name, engine='openpyxl',mode='w') as writer:
            
            # 初始化history_log字典
            history_log = {}
            # 读取现有history.json文件中的数据
            try:
                with open('history.json', 'r', encoding='utf-8') as file:
                    existing_data = json.load(file)
            except FileNotFoundError:
                existing_data = {}


            #遍历每列车工作表，并进行写入
            for index, row in df_TS_info.iterrows():
                start_col_num = int(row['Start_Column'])
                end_col_num = int(row['End_Column'])
                merge_context = row['Merge_Context']
                header_range = f"{get_column_letter(start_col_num)}9:{get_column_letter(end_col_num)}9"

                df_i = get_data_from_range(sht1, header_range, start_col_num, end_col_num)

                last_header = df_i.columns[-1]
                if pd.isnull(last_header):  # 检查是否为空值
                    new_header = sht1.range(f"{get_column_letter(end_col_num)}7").value
                    df_i.rename(columns={last_header: new_header}, inplace=True)  # 修改列名
                    # print(f"Modified the last header to: {new_header}")
                else:
                    print("The last header was not empty, no modification needed.")
            
                
                merged_df = pd.concat([df1.reset_index(drop=True), df_i.reset_index(drop=True)], axis=1)
                #把列名中包含 '售后质量', 'Engineer', '质量-外控', '售后质量', '采购', '运维', '项目', '工程' 的列清除
                columns_to_remove = [col for col in merged_df.columns if any(substring in col for substring in columns_to_drop)]
                merged_df.drop(columns=columns_to_remove, inplace=True, errors='ignore')
                
                # print(merged_df.columns)
                
                #将["列汇总"]这种的空值行清除                
                merged_df = merged_df.dropna(subset=["列汇总"])

                # 计算不含标题的实际数据行数，并命名变量为 sum_CN（表示该项目所有的变更总数）
                sum_CN = merged_df.shape[0]
                

                # 筛选条件：筛选出“列汇总”中含有“未完成”的行，并命名变量为 df_OPEN（表示该项目的未完成变更）
                df_OPEN = merged_df[merged_df['列汇总'].str.contains('未完成')]
                sum_OPEN = df_OPEN.shape[0]

                # # 1. 找出所有包含“生产”的列名
                # index_lst = [col for col in df_OPEN.columns if '生产' in col]

                # # 2. 筛选出含有“未完成”的行
                # # 首先，构造一个布尔索引，用于标记哪些行在index_lst中的任一列包含“未完成”
                # mask = df_OPEN.apply(lambda row: any('未完成' in str(row[col]) for col in index_lst), axis=1)

                # # 应用筛选
                # df_OPEN_filtered = df_OPEN[mask]

                sum_MF_OPEN_CN = get_unfinished_data('生产',df_OPEN)
                sum_OT_OPEN_CN = get_unfinished_data('外协',df_OPEN)
                sum_PL_OPEN_CN = get_unfinished_data('制造分部',df_OPEN)

                # 构建history_log字典
                current_date = datetime.now().strftime('%Y%m%d')
                book_name_history = f"{book_name}history"
                
                Project_ID = book_name_history
                TS = merge_context

                if Project_ID not in existing_data:
                    existing_data[Project_ID] = {}
                if TS not in existing_data[Project_ID]:
                    existing_data[Project_ID][TS] = {}
                if current_date not in existing_data[Project_ID][TS]:
                    existing_data[Project_ID][TS][current_date] = {}

                existing_data[Project_ID][TS][current_date]["Sum_MF_OPEN_CN"] = sum_MF_OPEN_CN
                existing_data[Project_ID][TS][current_date]["Sum_OT_OPEN_CN"] = sum_OT_OPEN_CN
                existing_data[Project_ID][TS][current_date]["Sum_PL_OPEN_CN"] = sum_PL_OPEN_CN
                
                with open('history.json', 'w', encoding='utf-8') as file:
                    json.dump(existing_data, file, ensure_ascii=False, indent=4)
                    print("History data has been updated.")

                df_OPEN.to_excel(writer, sheet_name=f"{merge_context}", startrow=4, startcol=0, index=False)
                activesheet = writer.sheets[f"{merge_context}"]

                # 合并单元格
                activesheet.merge_cells(start_row=1, start_column=7, end_row=4, end_column=12)

                # 设置合并单元格的值
                activesheet.cell(row=1, column=7).value = f"{merge_context}车辆变更状态"

                activesheet.cell(row=1, column=2).value = "变更总数"
                activesheet.cell(row=1, column=3).value = sum_CN
                activesheet.cell(row=1, column=4).value = "未关闭"
                activesheet.cell(row=2, column=4).value = "车间"
                activesheet.cell(row=3, column=4).value = "外协"
                activesheet.cell(row=4, column=4).value = "计划"
                
                        
                activesheet.cell(row=1, column=5).value = sum_OPEN
                activesheet.cell(row=2,column=5).value = sum_MF_OPEN_CN
                activesheet.cell(row=3, column=5).value = sum_OT_OPEN_CN
                activesheet.cell(row=4, column=5).value = sum_PL_OPEN_CN



                #调整列宽
                activesheet.column_dimensions['B'].width = 16
                activesheet.column_dimensions['C'].width = 20



                # 创建自定义的填充样式
                fill = PatternFill(start_color="ADD8E6",  # 浅蓝色的RGB代码
                                    end_color="ADD8E6",
                                    fill_type="solid")
                
                # 设置字体为黑体
                font = Font(name='黑体', bold=True, size=14)  # 注意：'SimHei'一般用于中文黑体，英文环境下可能需要其他字体名称
                
                # 设置单元格内容居中
                alignment = Alignment(horizontal="center", vertical="center")

                # 应用样式
                activesheet.cell(row=1, column=7).fill = fill
                activesheet.cell(row=1, column=7).font = font
                activesheet.cell(row=1, column=7).alignment = alignment

                # 应用格式到指定的单元格
                apply_format(activesheet.cell(row=1, column=7), font_size=20)  # 标题行可能需要更大字体
                apply_format(activesheet.cell(row=1, column=2))
                apply_format(activesheet.cell(row=1, column=3))
                apply_format(activesheet.cell(row=1, column=4))
                apply_format(activesheet.cell(row=1, column=5))
                apply_format(activesheet.cell(row=2, column=4))
                apply_format(activesheet.cell(row=2, column=5))
                apply_format(activesheet.cell(row=3, column=4))
                apply_format(activesheet.cell(row=3, column=5))
                apply_format(activesheet.cell(row=4, column=4))
                apply_format(activesheet.cell(row=3, column=5))
                apply_format(activesheet.cell(row=4, column=5))

                add_borders(activesheet)



                # 设置第3行为标题行，并开启自动换行
                for col in activesheet.iter_cols(min_col=1, max_col=activesheet.max_column, min_row=5, max_row=5):
                    for cell in col:
                        cell.font = Font(name='等线', size=11, bold=True)
                        cell.alignment = Alignment(wrapText=True, vertical='center', horizontal='center')
                        # cell.alignment = openpyxl.styles.Alignment(wrap_text=True)  # 启用自动换行

                # 调整第五行的行高
                activesheet.row_dimensions[5].height = 36
                # 确定数据起始行和结束行，以及列范围
                start_row = 5  # 数据起始行
                end_row = activesheet.max_row  # 数据结束行（假设数据连续到最后一行）
                column_letters = 'D'  # 假设数据从D列开始
                end_column = get_column_letter(activesheet.max_column)  # 获取最大列字母

                # 设置筛选范围，从第三行开始到工作表的最后一行和列
                data_range = f"{column_letters}{start_row}:{end_column}{end_row}"

                # 启用筛选
                activesheet.auto_filter.ref = data_range

                      
            
            
                sheets_pbar.update(1)
    


    print(f"数据已成功写入到 {excel_file_name}")
    # 关闭原工作簿，根据需要可取消注释
    wb.save()
    wb.app.quit()

                



def load_or_calculate_data(sht1, book_name):
    # 定义历史数据文件路径
    history_path = "history.json"

    # 初始化history_data为一个空字典
    history_data = {}

    # 尝试从文件加载历史数据
    if os.path.exists(history_path):
        try:
            with open(history_path, 'r',encoding='utf-8') as file:
                history_data = json.load(file)
                
            # 检查是否有与book_name匹配的project_ID
            if book_name in history_data:
                df_TS_info = pd.DataFrame(history_data[book_name]['df_TS_info'])
                df_Car_info = pd.DataFrame(history_data[book_name]['df_Car_info'])
                train_consist = history_data[book_name]['train_consist']
                print(f"Data for project '{book_name}' loaded from history.json.")
                return df_TS_info, df_Car_info, train_consist, book_name
            
            else:
                print(f"No data found for project '{book_name}' in history.json. Calculating new data...")
        
        except Exception as e:
            print(f"Error loading data from history.json: {e}")

    # 如果文件不存在或没有找到匹配的book_name，执行原始代码逻辑
    data_TS = extract_merge_info(sht1, 6, 'Z')
    data_Car = extract_merge_info(sht1, 8, 'Z')

    df_TS_info = pd.DataFrame(data_TS)
    df_Car_info = pd.DataFrame(data_Car)
    

    try:
        train_consist = (df_TS_info['Merged_Cell_Count'][0] - 1) / df_Car_info['Merged_Cell_Count'][0]
    except Exception as e:
        print(f"Error calculating train_consist: {e}")
        train_consist = None

    # 更新history.json文件
    try:
        # 添加当前book_name的数据
        history_data[book_name] = {
            'df_TS_info': df_TS_info.to_dict(orient='records'),
            'df_Car_info': df_Car_info.to_dict(orient='records'),
            'train_consist': train_consist,
            'project_ID': book_name
        }

        with open(history_path, 'w',encoding='utf-8') as file:
            json.dump(history_data, file, ensure_ascii=False)
        print(f"Data for project '{book_name}' saved to history.json.")
    except Exception as e:
        print(f"Error saving data to history.json: {e}")

    return df_TS_info, df_Car_info, train_consist, book_name



def get_merge_info(cell):
    """获取合并单元格的信息"""
    if cell.api.MergeCells:
        merge_area = cell.api.MergeArea
        return (
            merge_area.Cells(1).Row,  # 起始行号
            merge_area.Cells(1).Column,  # 起始列号
            merge_area.Cells(merge_area.Rows.Count, 1).Row,  # 结束行号
            merge_area.Cells(1, merge_area.Columns.Count).Column  # 结束列号
        )
    else:
        return cell.row, cell.column, cell.row, cell.column
    
# 定义函数获取数据
def get_data_from_range(sheet, header_range, start_col_num, end_col_num):
    start_col = xw.utils.col_name(start_col_num)
    end_col = xw.utils.col_name(end_col_num)
    headers = sheet.range(header_range).value
    start_row = 10
    last_row = sheet.cells.last_cell.row
    end_row = sheet.range(f'{end_col}{last_row}').end('up').row
    data_range = sheet.range(f'{start_col}{start_row}:{end_col}{end_row}')
    data = data_range.value
    df = pd.DataFrame(data, columns=headers[:len(data[0])])
    df.dropna(how='all', inplace=True)
    return df

def get_unfinished_data(str1, df_OPEN):
    # 1. 找出所有包含str1的列名
    index_lst = [col for col in df_OPEN.columns if str1 in col]

    # 2. 筛选出含有“未完成”的行
    # 首先，构造一个布尔索引，用于标记哪些行在index_lst中的任一列包含“未完成”
    mask = df_OPEN.apply(lambda row: any('未完成' in str(row[col]) for col in index_lst), axis=1)

    # 应用筛选
    df_OPEN_filtered = df_OPEN[mask]
    sum_filter_OPEN = df_OPEN_filtered.shape[0]

    return sum_filter_OPEN


def add_borders(sheet, start_row=1, start_col=2, end_row=4, end_col=12):
    """
    为指定单元格范围添加边框。
    :param sheet: 工作表对象。
    :param start_row: 起始行号。
    :param start_col: 起始列号。
    :param end_row: 结束行号。
    :param end_col: 结束列号。
    """
    thin_border = Border(left=Side(style='thin'), 
                        right=Side(style='thin'), 
                        top=Side(style='thin'), 
                        bottom=Side(style='thin'))
    
    for row in sheet.iter_rows(min_row=start_row, max_row=end_row, min_col=start_col, max_col=end_col):
        for cell in row:
            cell.border = thin_border



def apply_format(cell, font_name='等线', font_size=14, font_color='FF0000', is_bold=True, border=True, align_center=True):
    """应用格式到单元格"""
    font = Font(name=font_name, color=font_color, bold=is_bold, size=font_size)
    cell.font = font
    if border:
        thin_border = Border(left=Side(style='thin'), 
                            right=Side(style='thin'), 
                            top=Side(style='thin'), 
                            bottom=Side(style='thin'))
        cell.border = thin_border
    if align_center:
        alignment = Alignment(horizontal='center', vertical='center')
        cell.alignment = alignment





# 提取合并单元格信息


def extract_merge_info(sheet, start_row, start_col):
    """提取合并单元格的信息，并过滤掉Merge_Context为空的记录"""
    max_column = sheet.used_range.last_cell.column
    data = []
    # data_lst = []
    for col_index in range(ord(start_col) - ord('A'), max_column + 1):
        col_letter = get_column_letter(col_index + 1)
        cell = sheet[f'{col_letter}{start_row}']
        try:
            start_row_num, start_col_num, end_row_num, end_col_num = get_merge_info(cell)
            start_address = f"{get_column_letter(start_col_num)}{start_row_num}"
            end_address = f"{get_column_letter(end_col_num)}{end_row_num}"
            merge_count = (end_col_num - start_col_num + 1) * (end_row_num - start_row_num + 1) if cell.api.MergeCells else 1
            merge_context = cell.value if cell.api.MergeCells else ''
            # 直接在这里过滤掉merge_context为空的记录
            if merge_context:
                # data_lst.append(merge_context)
                data.append({
                    'Start_Address': start_address,
                    'End_Address': end_address,
                    'Start_Column': start_col_num,
                    'End_Column': end_col_num,
                    'Merged_Cell_Count': merge_count,
                    'Merge_Context': merge_context
                })
    


        except Exception as e:
            print(f"处理列 {col_letter} 时发生错误: {e}")
            
        
    # print(f"data多级字典:{data_lst}")
    
    return data

def build_project_car_dict(project_ID,df_TS_info, df_Car_info, train_consist ):
    """
    构建以project_ID为顶层键，TS为次级键，car列表为值的多级嵌套字典。
    :param df_TS_info: 包含列车段信息的DataFrame
    :param df_Car_info: 包含车厢信息的DataFrame
    :param train_consist: 列车段与车厢的比例
    :param project_ID: 项目ID
    :return: 构建好的多级嵌套字典
    """
    project_dict = {}  # 初始化多级嵌套字典

    # 遍历 df_TS_info 中的每一行
    for index, ts_row in df_TS_info.iterrows():
        ts_id = ts_row['Merge_Context']
        
        # 计算车厢的起始和结束索引
        start_idx = int(index * train_consist)
        # 特殊处理：最后一个列车段可能不足train_consist的数量
        if index == len(df_TS_info) - 1:
            end_idx = len(df_Car_info)
        else:
            end_idx = min(int((index + 1) * train_consist), len(df_Car_info))
        
        # 根据索引获取车厢列表
        cars_for_ts = df_Car_info.iloc[start_idx:end_idx]['Merge_Context'].tolist()

        # 如果project_ID尚未存在于字典中，创建一个新的字典
        if project_ID not in project_dict:
            project_dict[project_ID] = {}
        
        # 将车厢列表添加到列车段字典下
        project_dict[project_ID][ts_id] = cars_for_ts
    
    return project_dict






if __name__ =='__main__':
    main()

